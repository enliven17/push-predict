// src/lib/comments-service.ts`nimport { supabase } from "@/utils/supabase/client";`n`nexport interface Comment {`n  id: number;`n  content: string;`n  user_address: string;`n  market_id?: number;`n  parent_id?: number;`n  created_at: string;`n  updated_at: string;`n  edited: boolean;`n  likes_count: number;`n  dislikes_count: number;`n  users?: {`n    username: string;`n    display_name: string;`n    profile_image_url?: string;`n  };`n  user?: {`n    username: string;`n    display_name: string;`n    profile_image_url?: string;`n  };`n  replies?: Comment[];`n  user_reaction?: "like" | "dislike" | null;`n}`n`nexport interface CommentReaction {`n  id: number;`n  comment_id: number;`n  user_address: string;`n  reaction_type: "like" | "dislike";`n  created_at: string;`n}`n`nexport class CommentsService {`n  // Get comments for a market with user data and reactions - FIXED VERSION`n  static async getMarketComments(`n    marketId: number,`n    userAddress?: string,`n  ): Promise<Comment[]> {`n    try {`n      console.log(`Fetching comments for market ${marketId}`);`n`n      // Get main comments (not replies) - Use * to get all fields`n      const { data: comments, error } = await supabase`n        .from("comments")`n        .select(`n          ``n          *,`n          users!comments_user_address_fkey (`n            username,`n            display_name,`n            profile_image_url`n          )`n        `,`n        )`n        .eq("market_id", marketId)`n        .is("parent_id", null)`n        .order("created_at", { ascending: false });`n`n      if (error) {`n        console.error("Error fetching comments:", error);`n        throw error;`n      }`n`n      console.log("Raw comments from DB:", comments);`n`n      // Get replies and user reactions for each comment`n      const commentsWithReplies = await Promise.all(`n        (comments || []).map(async (comment) => {`n          const replies = await this.getCommentReplies(comment.id, userAddress);`n          const userReaction = userAddress`n            ? await this.getUserReaction(comment.id, userAddress)`n            : null;`n`n          const processedComment = {`n            ...comment,`n            user: comment.users,`n            replies,`n            user_reaction: userReaction,`n          };`n`n          console.log(`Processed comment ${comment.id}:`, {`n            likes_count: processedComment.likes_count,`n            dislikes_count: processedComment.dislikes_count,`n            user_reaction: processedComment.user_reaction,`n          });`n`n          return processedComment;`n        }),`n      );`n`n      console.log("Final comments with replies:", commentsWithReplies);`n      return commentsWithReplies;`n    } catch (error) {`n      console.error("Error fetching market comments:", error);`n      return [];`n    }`n  }`n`n  // Get replies for a specific comment`n  static async getCommentReplies(`n    commentId: number,`n    userAddress?: string,`n  ): Promise<Comment[]> {`n    try {`n      const { data: replies, error } = await supabase`n        .from("comments")`n        .select(`n          ``n          *,`n          users!comments_user_address_fkey (`n            username,`n            display_name,`n            profile_image_url`n          )`n        `,`n        )`n        .eq("parent_id", commentId)`n        .order("created_at", { ascending: true });`n`n      if (error) throw error;`n`n      // Add user reactions for replies`n      const repliesWithReactions = await Promise.all(`n        (replies || []).map(async (reply) => {`n          const userReaction = userAddress`n            ? await this.getUserReaction(reply.id, userAddress)`n            : null;`n`n          return {`n            ...reply,`n            user: reply.users,`n            user_reaction: userReaction,`n          };`n        }),`n      );`n`n      return repliesWithReactions;`n    } catch (error) {`n      console.error("Error fetching comment replies:", error);`n      return [];`n    }`n  }`n`n  // Add a new comment`n  static async addComment({`n    content,`n    userAddress,`n    marketId,`n    parentId,`n  }: {`n    content: string;`n    userAddress: string;`n    marketId?: number;`n    parentId?: number;`n  }): Promise<Comment | null> {`n    try {`n      const { data, error } = await supabase`n        .from("comments")`n        .insert({`n          content: content.trim(),`n          user_address: userAddress,`n          market_id: marketId,`n          parent_id: parentId,`n        })`n        .select(`n          ``n          *,`n          users!comments_user_address_fkey (`n            username,`n            display_name,`n            profile_image_url`n          )`n        `,`n        );`n`n      if (error) throw error;`n`n      // Get the first inserted comment`n      const insertedComment = data?.[0];`n      if (!insertedComment) throw new Error("Failed to insert comment");`n`n      return {`n        ...insertedComment,`n        user: insertedComment.users,`n        replies: [],`n        user_reaction: null,`n      };`n    } catch (error) {`n      console.error("Error adding comment:", error);`n      throw error;`n    }`n  }`n`n  // Update a comment`n  static async updateComment(`n    commentId: number,`n    content: string,`n    userAddress: string,`n  ): Promise<boolean> {`n    try {`n      const { error } = await supabase`n        .from("comments")`n        .update({`n          content: content.trim(),`n          edited: true,`n          updated_at: new Date().toISOString(),`n        })`n        .eq("id", commentId)`n        .eq("user_address", userAddress);`n`n      if (error) throw error;`n      return true;`n    } catch (error) {`n      console.error("Error updating comment:", error);`n      return false;`n    }`n  }`n`n  // Delete a comment`n  // In src/lib/comments-service.ts - Update the deleteComment method`n  static async deleteComment(`n    commentId: number,`n    userAddress: string,`n  ): Promise<boolean> {`n    try {`n      console.log(`n        `Attempting to delete comment ${commentId} by user ${userAddress}`,`n      );`n`n      // First check if the comment exists and belongs to the user`n      const { data: existingComment, error: fetchError } = await supabase`n        .from("comments")`n        .select("id, user_address")`n        .eq("id", commentId)`n        .eq("user_address", userAddress);`n`n      if (fetchError) {`n        console.error("Error checking comment ownership:", fetchError);`n        return false;`n      }`n`n      if (!existingComment || existingComment.length === 0) {`n        console.error("Comment not found or user not authorized");`n        return false;`n      }`n`n      // Delete associated reactions first (if any)`n      const { error: reactionsDeleteError } = await supabase`n        .from("comment_reactions")`n        .delete()`n        .eq("comment_id", commentId);`n`n      if (reactionsDeleteError) {`n        console.error(`n          "Error deleting comment reactions:",`n          reactionsDeleteError,`n        );`n        // Don't return false here, continue with comment deletion`n      }`n`n      // Delete the comment`n      const { error: deleteError } = await supabase`n        .from("comments")`n        .delete()`n        .eq("id", commentId)`n        .eq("user_address", userAddress);`n`n      if (deleteError) {`n        console.error("Error deleting comment:", deleteError);`n        return false;`n      }`n`n      console.log("Comment deleted successfully");`n      return true;`n    } catch (error) {`n      console.error("Exception deleting comment:", error);`n      return false;`n    }`n  }`n`n  // React to a comment (like/dislike)`n  static async reactToComment(`n    commentId: number,`n    userAddress: string,`n    reactionType: "like" | "dislike",`n  ): Promise<boolean> {`n    try {`n      console.log(`n        `Reacting to comment ${commentId} with ${reactionType} for user ${userAddress}`,`n      );`n`n      // Check if user already has a reaction`n      const { data: existingReactions, error: fetchError } = await supabase`n        .from("comment_reactions")`n        .select("*")`n        .eq("comment_id", commentId)`n        .eq("user_address", userAddress);`n`n      if (fetchError) {`n        console.error("Error fetching existing reaction:", fetchError);`n        return false;`n      }`n`n      const existingReaction =`n        existingReactions && existingReactions.length > 0`n          ? existingReactions[0]`n          : null;`n`n      console.log("Existing reaction:", existingReaction);`n`n      if (existingReaction) {`n        if (existingReaction.reaction_type === reactionType) {`n          // Remove reaction if it's the same`n          console.log("Removing existing reaction");`n          const { error } = await supabase`n            .from("comment_reactions")`n            .delete()`n            .eq("id", existingReaction.id);`n`n          if (error) {`n            console.error("Error deleting reaction:", error);`n            return false;`n          }`n        } else {`n          // Update reaction if it's different`n          console.log("Updating existing reaction");`n          const { error } = await supabase`n            .from("comment_reactions")`n            .update({ reaction_type: reactionType })`n            .eq("id", existingReaction.id);`n`n          if (error) {`n            console.error("Error updating reaction:", error);`n            return false;`n          }`n        }`n      } else {`n        // Add new reaction`n        console.log("Adding new reaction");`n        const { error } = await supabase.from("comment_reactions").insert({`n          comment_id: commentId,`n          user_address: userAddress,`n          reaction_type: reactionType,`n        });`n`n        if (error) {`n          console.error("Error inserting new reaction:", error);`n          return false;`n        }`n      }`n`n      // Update comment counts and wait for completion`n      console.log("Updating comment counts");`n      await this.updateCommentReactionCounts(commentId);`n`n      console.log("Reaction completed successfully");`n      return true;`n    } catch (error) {`n      console.error("Error reacting to comment:", error);`n      return false;`n    }`n  }`n`n  // Get user's reaction to a comment`n  static async getUserReaction(`n    commentId: number,`n    userAddress: string,`n  ): Promise<"like" | "dislike" | null> {`n    try {`n      const { data, error } = await supabase`n        .from("comment_reactions")`n        .select("reaction_type")`n        .eq("comment_id", commentId)`n        .eq("user_address", userAddress);`n`n      if (error) {`n        console.error("Error fetching user reaction:", error);`n        return null;`n      }`n`n      // Return the first result or null`n      return data && data.length > 0`n        ? (data[0].reaction_type as "like" | "dislike")`n        : null;`n    } catch (error) {`n      console.error("Error in getUserReaction:", error);`n      return null;`n    }`n  }`n`n  // Update reaction counts for a comment - IMPROVED VERSION`n  static async updateCommentReactionCounts(commentId: number): Promise<void> {`n    try {`n      console.log(`Updating reaction counts for comment ${commentId}`);`n`n      // Count likes and dislikes`n      const { data: reactions, error } = await supabase`n        .from("comment_reactions")`n        .select("reaction_type")`n        .eq("comment_id", commentId);`n`n      if (error) {`n        console.error("Error fetching reactions for count:", error);`n        return;`n      }`n`n      const likes =`n        reactions?.filter((r) => r.reaction_type === "like").length || 0;`n      const dislikes =`n        reactions?.filter((r) => r.reaction_type === "dislike").length || 0;`n`n      console.log(`n        `Calculated counts for comment ${commentId}: likes=${likes}, dislikes=${dislikes}`,`n      );`n`n      // Update comment with new counts and return updated data`n      const { data: updatedComment, error: updateError } = await supabase`n        .from("comments")`n        .update({`n          likes_count: likes,`n          dislikes_count: dislikes,`n        })`n        .eq("id", commentId)`n        .select("id, likes_count, dislikes_count");`n`n      if (updateError) {`n        console.error("Error updating comment counts:", updateError);`n        return;`n      }`n`n      console.log("Successfully updated comment counts:", updatedComment);`n    } catch (error) {`n      console.error("Error updating comment reaction counts:", error);`n    }`n  }`n`n  // Get comment count for a market`n  static async getMarketCommentCount(marketId: number): Promise<number> {`n    try {`n      const { count, error } = await supabase`n        .from("comments")`n        .select("*", { count: "exact", head: true })`n        .eq("market_id", marketId);`n`n      if (error) throw error;`n      return count || 0;`n    } catch (error) {`n      console.error("Error getting comment count:", error);`n      return 0;`n    }`n  }`n}